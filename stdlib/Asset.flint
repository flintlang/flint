// Any currency should implement this trait to be able to use the currency
// fully. The default implementations should be left intact, only
// `getRawValue` and `setRawValue` need to be implemented.

// TODO: semantic check preventing cross-asset transfers
struct trait Asset {
  // Initialises the asset "unsafely", i.e. from `amount` given as an integer.
  init(unsafeRawValue: Int)
  
  // Initialises the asset by transferring `amount` from an existing asset.
  // Should check if `source` has sufficient funds, and cause a fatal error
  // if not.
  init(source: inout Asset, amount: Int)
  
  // Initialises the asset by transferring all funds from `source`.
  // `source` should be left empty.
  init(source: inout Asset)
  
  // TODO: These implementations cause the compiler to crash due to calling
  // a mutating function from the constructor.
  // See: https://github.com/flintrocks/flint/issues/30
  //init(unsafeRawValue: Int) {
  //  setRawValue(unsafeRawValue)
  //}
  //
  //init(source: inout Asset, amount: Int) {
  //  if source.getRawValue() < amount {
  //    fatalError()
  //  }
  //  
  //  source.setRawValue(source.getRawValue() - amount)
  //  setRawValue(getRawValue() + amount)
  //}
  //
  //init(source: inout Asset) {
  //  let value: Int = source.getRawValue()
  //  source.setRawValue(0)
  //  setRawValue(0)
  //}
  
  // Moves `amount` from `source` into `this` asset.
  mutating func transfer(source: inout Asset, amount: Int) {
    if source.getRawValue() < amount {
      fatalError()
    }
    
    source.setRawValue(source.getRawValue() - amount)
    setRawValue(getRawValue() + amount)
  }
  
  // Moves all funds from `source` into `this` asset.
  mutating func transfer(source: inout Asset) {
    transfer(&source, source.getRawValue())
  }
  
  // Returns the funds contained in this asset, as an integer.
  mutating func setRawValue(value: Int) -> Int
  
  // Returns the funds contained in this asset, as an integer.
  func getRawValue() -> Int
}
